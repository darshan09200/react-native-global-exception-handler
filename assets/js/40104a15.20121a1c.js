"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[727],{2725:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"native-crash-handling","title":"Native Crash Handling","description":"The library provides native exception handling for iOS and Android to catch crashes that occur in native code.","source":"@site/docs/native-crash-handling.md","sourceDirName":".","slug":"/native-crash-handling","permalink":"/react-native-global-exception-handler/docs/native-crash-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/darshan09200/react-native-global-exception-handler/tree/main/website/docs/native-crash-handling.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"native-crash-handling","sidebar_position":4,"title":"Native Crash Handling"},"sidebar":"docSidebar","previous":{"title":"Usage","permalink":"/react-native-global-exception-handler/docs/usage"},"next":{"title":"Customization","permalink":"/react-native-global-exception-handler/docs/customization"}}');var a=r(4848),t=r(8453);const s={id:"native-crash-handling",sidebar_position:4,title:"Native Crash Handling"},o=void 0,l={},c=[{value:"How It Works",id:"how-it-works",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Platform-Specific Options",id:"platform-specific-options",level:2},{value:"Android Options",id:"android-options",level:3},{value:"iOS Options",id:"ios-options",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keep Handler Lightweight",id:"1-keep-handler-lightweight",level:3},{value:"2. Persist Crash Data Locally",id:"2-persist-crash-data-locally",level:3},{value:"3. Integration with Error Monitoring",id:"3-integration-with-error-monitoring",level:3},{value:"Testing Native Crashes",id:"testing-native-crashes",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"The library provides native exception handling for iOS and Android to catch crashes that occur in native code."}),"\n",(0,a.jsx)(n.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,a.jsx)(n.p,{children:"The library uses platform-specific native exception handlers:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"iOS"}),": Installs an NSException handler and signal handlers"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Android"}),": Installs an UncaughtExceptionHandler"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"When a native crash occurs, your handler function is called with the error message before the app terminates (or continues based on your options)."}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { setNativeExceptionHandler } from 'react-native-global-exception-handler';\n\nawait setNativeExceptionHandler((errorString) => {\n  // errorString contains the native error message/stack\n  console.log('Native crash:', errorString);\n  \n  // Send to error monitoring\n  reportToSentry(errorString);\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"platform-specific-options",children:"Platform-Specific Options"}),"\n",(0,a.jsx)(n.h3,{id:"android-options",children:"Android Options"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"await setNativeExceptionHandler((errorString) => {\n  // Handle error\n}, {\n  forceAppToQuit: true,  // Force app to terminate after handler runs\n  callPreviouslyDefinedHandler: false  // Call previous handler\n});\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"forceAppToQuit"}),": If ",(0,a.jsx)(n.code,{children:"true"}),", forces the app to quit after your handler runs (Android only)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"callPreviouslyDefinedHandler"}),": If ",(0,a.jsx)(n.code,{children:"true"}),", calls any previously defined native handler"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"ios-options",children:"iOS Options"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"await setNativeExceptionHandler((errorString) => {\n  // Handle error\n}, {\n  callPreviouslyDefinedHandler: true  // Chain with previous handler\n});\n"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"callPreviouslyDefinedHandler"}),": If ",(0,a.jsx)(n.code,{children:"true"}),", calls any previously defined native exception handler"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Not all crashes can be intercepted (e.g., some signal-based crashes)"}),"\n",(0,a.jsx)(n.li,{children:"On iOS, certain types of signals cannot be safely caught"}),"\n",(0,a.jsx)(n.li,{children:"Handler runs synchronously before crash, so keep it lightweight"}),"\n",(0,a.jsx)(n.li,{children:"Network calls may not complete before app terminates"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"1-keep-handler-lightweight",children:"1. Keep Handler Lightweight"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"await setNativeExceptionHandler((errorString) => {\n  // \u2705 Good: Quick synchronous operations\n  console.log(errorString);\n  \n  // \u274c Bad: Async operations that may not complete\n  // await fetch('...'); // May not finish before crash\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-persist-crash-data-locally",children:"2. Persist Crash Data Locally"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import AsyncStorage from '@react-native-async-storage/async-storage';\n\nawait setNativeExceptionHandler((errorString) => {\n  // Store crash info locally\n  try {\n    AsyncStorage.setItem('lastCrash', JSON.stringify({\n      error: errorString,\n      timestamp: Date.now()\n    }));\n  } catch (e) {\n    console.log('Failed to save crash:', e);\n  }\n});\n\n// On next app launch, check for stored crashes\nasync function checkForPreviousCrashes() {\n  const lastCrash = await AsyncStorage.getItem('lastCrash');\n  if (lastCrash) {\n    // Send to monitoring service\n    await reportCrash(JSON.parse(lastCrash));\n    await AsyncStorage.removeItem('lastCrash');\n  }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-integration-with-error-monitoring",children:"3. Integration with Error Monitoring"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import * as Sentry from '@sentry/react-native';\n\nawait setNativeExceptionHandler((errorString) => {\n  // Sentry has its own native crash handling, but you can add custom logic\n  console.log('Native crash detected:', errorString);\n  \n  // Add breadcrumbs or custom data\n  Sentry.addBreadcrumb({\n    message: 'Native crash handler invoked',\n    data: { error: errorString }\n  });\n});\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing-native-crashes",children:"Testing Native Crashes"}),"\n",(0,a.jsxs)(n.p,{children:["Use ",(0,a.jsx)(n.code,{children:"simulateNativeCrash"})," to test your handler (\u26a0\ufe0f will crash your app):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"import { simulateNativeCrash, CrashType } from 'react-native-global-exception-handler';\n\n// Test different crash types\nsimulateNativeCrash(CrashType.nsexception);      // iOS NSException\nsimulateNativeCrash(CrashType.array_bounds);     // Array out of bounds\nsimulateNativeCrash(CrashType.memory_access);    // Memory access violation\n"})}),"\n",(0,a.jsxs)(n.p,{children:["See ",(0,a.jsx)(n.a,{href:"./api#testing--utilities",children:"API Reference"})," for all available crash types."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>o});var i=r(6540);const a={},t=i.createContext(a);function s(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);